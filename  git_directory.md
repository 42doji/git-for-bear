================================

* **Working Directory**: 개발자가 실제 파일을 수정하는 작업 공간.
* **.git**: 모든 버전 정보가 저장되는 곳.

---

### 1. `objects/` 객체 데이터베이스

* **역할**: Git의 모든 데이터 조각(**Blob**, **Tree**, **Commit**, **Tag** 객체)이 저장되는 데이터베이스
* **작동 방식**: '콘텐츠 주소 지정' 방식을 사용,  **SHA-1** 알고리즘으로 해시하여 40자의 고유한 키(이름)를 만들고, 그 이름으로 객체를 저장 

#### 객체

* **Blob (블롭)**: 파일의 **내용(raw data)** 저장
* **Tree (트리)**: 디렉토리 구조. 특정 시점의 디렉토리에 어떤 파일과 하위 디렉토리가 있는지에 대한 정보. 
* **Commit (커밋)**: 프로젝트의 특정 시점 스냅샷에 대한 **메타데이터**. 해당 시점의 최상위 Tree 객체 해시, 부모 커밋 해시, 작성자, 커밋 메시지 등을 포함. 커밋은 스냅샷 그 자체가 아니라, 스냅샷을 구성하는 Tree를 가리키는 포인터
* **Tag (태그)**: 특정 커밋에 사람이 읽기 쉬운 이름표(예: `v1.0`)를 붙인다.

이 구조 때문에 Git의 역사는 **위변조가 거의 불가능**하다. 파일 내용이 1바이트만 바뀌어도 Blob 해시가 바뀌고, 연쇄적으로 상위 Tree와 모든 후속 Commit의 해시까지 전부 바뀌기 때문이다.

### 2. `index` 스테이지

* **역할**: 워킹 디렉토리와 Git 저장소(`.git`) 사이의 **완충 지대**다. 다음 커밋에 포함할 변경 사항을 선별
* **작동 방식**: `git add` 명령어를 실행하면, Git은 워킹 디렉토리의 파일 내용으로 Blob 객체를 만들어 `objects/`에 저장하고, 이 Blob 객체의 해시 정보를 `index` 파일에 기록한다.
* `git commit` 명령어는 워킹 디렉토리를 보는 것이 아니라, 오직 `index` 파일에 준비된 내용만을 바탕으로 새로운 커밋을 생성한다. `index`의 내용을 기반으로 Tree 객체를 만들고, 이를 가리키는 Commit 객체를 만드는 식이다.
* **장점**: `index` 덕분에 하나의 큰 변경 사항도 여러 개의 작고 논리적인 **'원자적 커밋(Atomic Commit)'**으로 나누어 기록할 수 있다.

### 3. `refs/`

* **역할**: `a1b2c3d...` 같은 40자리 SHA-1 해시 대신 `main`이나 `v1.0`처럼 사람이 읽기 쉬운 이름으로 특정 커밋을 가리키게 해준다.
* **`refs/heads/`**: 로컬 브랜치들이 저장된다. `main`이라는 파일 안에는 `main` 브랜치가 가리키는 최신 커밋의 SHA-1 해시가 적혀있다. 새 커밋이 생기면 이 파일의 내용이 새 커밋 해시로 갱신된다.
* **`refs/tags/`**: 태그에 대한 참조가 저장된다.
* **`HEAD`**: `.git` 디렉토리 최상단에 있는 가장 중요한 파일로, **"현재 작업 중인 위치"**를 가리키는 포인터다.
    * **일반 상태 (Symbolic Reference)**: `ref: refs/heads/main`처럼 특정 브랜치를 가리킨다. 이 상태에서 커밋하면 `HEAD`가 가리키는 브랜치가 자동으로 앞으로 나아간다.
    * **분리된 HEAD (Detached HEAD)**: 특정 커밋의 SHA-1 해시를 직접 가리킨다. 과거 커밋이나 태그를 직접 `checkout`했을 때 발생한다. 이 상태에서 작업한 커밋은 어떤 브랜치에도 속하지 않아 잃어버릴 수 있으므로 주의해야 한다.

Git의 **브랜치**가 이토록 빠르고 가벼운 이유는, 브랜치가 복잡한 구조가 아니라 단순히 **커밋 해시가 적힌 텍스트 파일 하나**(`refs/heads/브랜치명`)에 불과하기 때문이다.

---

## Git 워크플로우와 .git 디렉토리의 상호작용

1.  **파일 수정**: `feature.txt` 파일을 만들고 내용을 채운다. (워킹 디렉토리의 변화. `.git`은 아직 모름)
2.  **`git add feature.txt` 실행**:
    * `feature.txt`의 내용으로 Blob 객체를 만들어 `.git/objects/`에 저장한다.
    * `.git/index` 파일에 `feature.txt`의 경로와 방금 만든 Blob 객체의 해시를 기록한다.
3.  **`git commit -m "메시지"` 실행**:
    * Git은 `.git/index` 파일의 내용을 바탕으로 Tree 객체를 생성하여 `.git/objects/`에 저장한다.
    * 이 Tree 객체의 해시, 부모 커밋 정보, 메시지 등을 담아 새로운 Commit 객체를 만들어 `.git/objects/`에 저장한다.
    * 현재 브랜치(예: `main`)가 이 새 Commit 객체의 해시를 가리키도록 `.git/refs/heads/main` 파일의 내용을 갱신한다.

---

### Blob 객체의 역할은?

Blob(Binary Large Object) 객체의 역할은 단 하나, **파일의 원시 데이터(내용)**를 저장하는 것이다. Blob은 파일 이름, 경로, 권한 같은 메타데이터는 전혀 담지 않고 오직 순수한 파일 콘텐츠만 담는다. 파일 내용이 같으면, 이름이나 경로가 다르더라도 동일한 Blob 객체 하나를 공유하여 저장 효율을 높인다.

### HEAD 파일이란?

HEAD 파일은 `.git` 디렉토리 최상위에 존재하는 특별한 파일로, **현재 체크아웃된 커밋을 가리키는 포인터**다. 이 파일의 내용을 통해 Git은 현재 사용자가 어느 브랜치, 또는 어느 특정 커밋 위에서 작업하고 있는지를 파악한다. 즉, "현재 작업 위치"를 알려주는 이정표와 같다.